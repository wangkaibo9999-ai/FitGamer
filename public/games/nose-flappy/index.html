<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nose Flappy</title>
    <style>
        :root {
            --ios-bg: #1a1c2c;
            --ios-glass: rgba(255, 255, 255, 0.12);
            --ios-blur: blur(25px);
            --ios-font: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
            --primary-accent: #34c759;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: var(--ios-font);
            background-color: #000;
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            aspect-ratio: 9/16;
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        #bg-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 1;
            filter: brightness(0.6);
            z-index: 0;
        }

        canvas {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
        }

        #video-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--ios-glass);
            transform: scaleX(-1);
            background: #000;
            z-index: 10;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* HUD Glassmorphism */
        .hud-capsule {
            position: absolute;
            background: var(--ios-glass);
            backdrop-filter: var(--ios-blur);
            -webkit-backdrop-filter: var(--ios-blur);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            font-size: 18px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        #score-display {
            top: 20px;
            left: 20px;
            color: #fff;
        }

        /* Overlays */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 100;
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 42px;
            margin-bottom: 10px;
            font-weight: 800;
            letter-spacing: -1px;
        }

        p {
            font-size: 18px;
            opacity: 0.8;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .btn {
            background: #fff;
            color: #000;
            padding: 16px 40px;
            border-radius: 30px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
        }

        .btn:active {
            transform: scale(0.92);
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0c1421;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Calibration Hint */
        #calibration-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--primary-accent);
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <img id="bg-image" src="bg.png" alt="Sky Background">
        <canvas id="game-canvas"></canvas>

        <div id="video-container">
            <video id="webcam" autoplay playsinline muted></video>
        </div>

        <div id="score-display" class="hud-capsule">
            <span>ğŸ¦</span> <span id="score-value">0</span>
        </div>

        <!-- Start/Game Over Overlay -->
        <div id="overlay">
            <h1 id="overlay-title">Nose Flappy</h1>
            <p id="overlay-desc">æŠ¬é«˜å¤´éƒ¨è®©é¸Ÿé£èµ·ï¼Œä½å¤´ä¸‹é™ã€‚<br>ç©¿è¿‡ç¼éš™ä»¥å¾—åˆ†ã€‚</p>
            <button id="start-btn" class="btn">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <!-- Loading Screen -->
        <div id="loading-screen">
            <div class="spinner"></div>
            <p id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI...</p>
            <p id="loading-status" style="font-size: 14px; opacity: 0.6; margin-top: 10px;"></p>
        </div>

        <div id="calibration-hint">è¯·å¯¹å‡†æ‘„åƒå¤´</div>
    </div>

    <!-- MediaPipe Libraries -->
    <script type="module">
        let FilesetResolver;
        let FaceLandmarker;
        let faceLandmarker;

        // --- I18N ---
        const translations = {
            zh: {
                loading: "æ­£åœ¨åŠ è½½æ¸¸æˆ...",
                title: "ä½“æ„Ÿ Flappy",
                instructions: "æŠ¬é«˜å¤´éƒ¨æ§åˆ¶å°é¸Ÿä¸Šå‡ ğŸ¦<br>ç©¿è¿‡éšœç¢ç‰©å¾—åˆ† ğŸŒ³",
                start: "å¼€å§‹æ¸¸æˆ",
                gameOver: "æ¸¸æˆç»“æŸ!",
                restart: "å†ç©ä¸€æ¬¡",
                scorePrefix: "å¾—åˆ†: ",
                calibration: "è¯·ç¡®ä¿è„¸éƒ¨åœ¨ç”»é¢ä¸­å¿ƒ",
                netError: "ç½‘ç»œè¿æ¥å¤±è´¥ï¼šè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é‡è¯•ã€‚",
                cameraError: "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼šè¯·ç¡®ä¿å·²æˆæƒæ‘„åƒå¤´æƒé™å¹¶åˆ·æ–°é¡µé¢ã€‚"
            },
            en: {
                loading: "Loading Game...",
                title: "Nose Flappy",
                instructions: "Lift your head to fly UP ğŸ¦<br>Pass pipes to score ğŸŒ³",
                start: "Start Game",
                gameOver: "Game Over!",
                restart: "Play Again",
                scorePrefix: "Score: ",
                calibration: "Center your face in view",
                netError: "Network failed. Please check connection and refresh.",
                cameraError: "Camera failed. Please allow camera access and refresh."
            }
        };

        const urlParams = new URLSearchParams(window.location.search);
        const lang = urlParams.get('lang') === 'zh' ? 'zh' : 'en';
        const t = translations[lang];

        // UI Initialization
        document.getElementById('overlay-title').innerText = t.title;
        document.getElementById('overlay-desc').innerHTML = t.instructions;
        document.getElementById('start-btn').innerText = t.start;
        document.getElementById('loading-text').innerText = t.loading;
        document.getElementById('calibration-hint').innerText = t.calibration;

        // --- Constants & Config ---
        const CANVAS_WIDTH = 1080;
        const CANVAS_HEIGHT = 1920;
        const PIPE_SPACING = 550;
        const PIPE_WIDTH = 160;
        const PIPE_GAP = 550;
        const BIRD_SIZE = 80;
        const GRAVITY = 0; // Handled by AI position
        const FLOAT_LERP = 0.2; // Smooth tracking

        // --- Assets ---
        const BIRD_IMG = new Image();
        // [ä¿®æ”¹æç¤º] å¦‚æœæƒ³æ›´æ¢å°é¸Ÿå›¾ç‰‡ï¼Œå¯ä»¥ä¿®æ”¹ä¸‹æ–¹çš„ src ä¸ºæ–°çš„å›¾ç‰‡ URL æˆ– Base64 æ•°æ®
        BIRD_IMG.src = `data:image/svg+xml;base64,${btoa(`
            <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <radialGradient id="gradBody" cx="40%" cy="40%" r="50%">
                        <stop offset="0%" style="stop-color:#FFEB3B;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#FBC02D;stop-opacity:1" />
                    </radialGradient>
                    <radialGradient id="gradEye" cx="30%" cy="30%" r="50%">
                        <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#E0E0E0;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Body -->
                <ellipse cx="45" cy="50" rx="35" ry="32" fill="url(#gradBody)" stroke="#000" stroke-width="2.5"/>
                <!-- Cheek -->
                <ellipse cx="45" cy="62" rx="10" ry="6" fill="#FF8A80" fill-opacity="0.4"/>
                <!-- Wing -->
                <path d="M 20 50 Q 15 30 35 45 Q 25 55 20 50" fill="#FFF" stroke="#000" stroke-width="2"/>
                <path d="M 22 42 L 30 46 M 23 48 L 32 50" stroke="#000" stroke-width="1.5" stroke-linecap="round" opacity="0.3"/>
                <!-- Eye -->
                <circle cx="65" cy="40" r="14" fill="url(#gradEye)" stroke="#000" stroke-width="2.5"/>
                <circle cx="72" cy="38" r="6" fill="#000"/>
                <circle cx="74" cy="36" r="2.5" fill="#FFF"/> <!-- Sparkle -->
                <!-- Beak -->
                <path d="M 75 48 L 98 55 L 75 68 Z" fill="#FF5252" stroke="#000" stroke-width="2"/>
                <path d="M 75 58 L 90 58" stroke="#000" stroke-width="1.5" opacity="0.5"/> <!-- Beak line -->
                <!-- Belly Highlight -->
                <ellipse cx="40" cy="70" rx="18" ry="8" fill="#FFF176" fill-opacity="0.5"/>
            </svg>
        `)}`;

        // --- Sound Manager ---
        class SoundManager {
            constructor() {
                this.ctx = null;
            }
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            playTone(freq, duration, type = 'sine', volume = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
            playPass() { this.playTone(880, 0.1, 'triangle', 0.05); }
            playHit() { this.playTone(150, 0.4, 'sawtooth', 0.1); }
        }
        const sfx = new SoundManager();

        // --- Game Objects ---
        class Bird {
            constructor() {
                this.y = CANVAS_HEIGHT / 2;
                this.targetY = CANVAS_HEIGHT / 2;
                this.x = CANVAS_WIDTH * 0.25;
                this.velocity = 0;
            }
            update(noseY) {
                const lastY = this.y;
                if (noseY !== null) {
                    let normalized = (noseY - 0.3) / (0.4);
                    normalized = Math.max(0, Math.min(1, normalized));
                    this.targetY = normalized * CANVAS_HEIGHT;
                }
                this.y += (this.targetY - this.y) * FLOAT_LERP;
                this.velocity = this.y - lastY;
            }
            draw(ctx) {
                ctx.save();
                // Use Math.round for pixel-perfect positioning to avoid jitter
                const drawX = Math.round(this.x);
                const drawY = Math.round(this.y);
                ctx.translate(drawX, drawY);

                // Rotation based on velocity
                const rotation = Math.max(-0.4, Math.min(0.4, this.velocity * 0.01));
                ctx.rotate(rotation);

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 45, BIRD_SIZE / 1.5, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw Image
                ctx.drawImage(BIRD_IMG, -BIRD_SIZE / 2, -BIRD_SIZE / 2, BIRD_SIZE, BIRD_SIZE);

                ctx.restore();
            }
        }

        class Pipe {
            constructor(x) {
                this.x = x;
                this.gapY = Math.random() * (CANVAS_HEIGHT - PIPE_GAP - 400) + 200;
                this.passed = false;
            }
            update(speed) {
                this.x -= speed;
            }
            draw(ctx) {
                const capHeight = 60;
                const capOverflow = 15;

                const drawSinglePipe = (x, y, w, h, isTop) => {
                    ctx.save();
                    // Round coordinates for jitter-free rendering
                    const rx = Math.round(x);
                    const ry = Math.round(y);
                    const rw = Math.round(w);
                    const rh = Math.round(h);

                    // Column Gradient
                    const grad = ctx.createLinearGradient(rx, 0, rx + rw, 0);
                    grad.addColorStop(0, '#2E7D32');
                    grad.addColorStop(0.3, '#4CAF50');
                    grad.addColorStop(0.5, '#A5D6A7');
                    grad.addColorStop(0.7, '#4CAF50');
                    grad.addColorStop(1, '#1B5E20');

                    // Pipe Body
                    ctx.fillStyle = grad;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.fillRect(rx, ry, rw, rh);
                    ctx.strokeRect(rx, ry, rw, rh);

                    // Cap
                    const capY = isTop ? ry + rh - capHeight : ry;
                    ctx.fillRect(rx - capOverflow, Math.round(capY), rw + capOverflow * 2, capHeight);
                    ctx.strokeRect(rx - capOverflow, Math.round(capY), rw + capOverflow * 2, capHeight);

                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(rx + rw * 0.15, ry, rw * 0.1, rh);

                    ctx.restore();
                };

                // Top Pipe
                drawSinglePipe(this.x, 0, PIPE_WIDTH, this.gapY, true);
                // Bottom Pipe
                drawSinglePipe(this.x, this.gapY + PIPE_GAP, PIPE_WIDTH, CANVAS_HEIGHT - (this.gapY + PIPE_GAP), false);
            }
            roundRect(ctx, x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.fill();
            }
        }

        // --- Game Setup ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const video = document.getElementById('webcam');
        let lastVideoTime = -1;
        let noseY = null;
        let gameState = 'START';
        let score = 0;
        let bird = new Bird();
        let pipes = [];
        let gameSpeed = 8;
        let frameId;

        // --- AI Logic (V2.1 Optimized) ---
        const CDN_CONFIG = {
            js: ["../lib/mediapipe/0.10.3/vision_bundle.mjs"],
            wasm: ["../lib/mediapipe/0.10.3"],
            models: ["../lib/mediapipe/models/face_landmarker.task"]
        };

        function showError(message, err) {
            const status = document.getElementById('loading-status');
            const isDebug = urlParams.get('debug') === 'true';
            status.innerText = message;
            status.style.color = "#ff3b30";
            if (isDebug) {
                const detail = document.createElement('div');
                detail.style.fontSize = '10px'; detail.style.marginTop = '10px';
                detail.innerHTML = `<code>${err?.message || err}</code>`;
                status.appendChild(detail);
            }
        }

        async function loadModule(index = 0) {
            const status = document.getElementById('loading-status');
            const isDebug = urlParams.get('debug') === 'true';
            const url = CDN_CONFIG.js[index];
            try {
                if (isDebug) status.innerText = `åŠ è½½æ ¸å¿ƒç»„ä»¶ (${index + 1}/${CDN_CONFIG.js.length})...`;
                const module = await import(url);
                FilesetResolver = module.FilesetResolver;
                FaceLandmarker = module.FaceLandmarker;
                return true;
            } catch (err) {
                console.error(`JSåŠ è½½å¤±è´¥: ${url}`, err);
                if (index < CDN_CONFIG.js.length - 1) return loadModule(index + 1);
                throw err;
            }
        }

        async function tryLoadAI(wasmIndex = 0, modelIndex = 0) {
            const status = document.getElementById('loading-status');
            const isDebug = urlParams.get('debug') === 'true';
            const wasmUrl = CDN_CONFIG.wasm[wasmIndex];
            const modelPath = CDN_CONFIG.models[modelIndex];
            try {
                if (isDebug) status.innerText = `é…ç½®è§†è§‰å¼•æ“ (${wasmIndex + 1}/${CDN_CONFIG.wasm.length})...`;
                const vision = await FilesetResolver.forVisionTasks(wasmUrl);
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: modelPath, delegate: "GPU" },
                    runningMode: "VIDEO", numFaces: 1
                });
                return true;
            } catch (err) {
                console.error(`å¼•æ“åˆå§‹åŒ–å¤±è´¥: ${wasmUrl}`, err);
                if (wasmIndex < CDN_CONFIG.wasm.length - 1) return tryLoadAI(wasmIndex + 1, modelIndex);
                if (modelIndex < CDN_CONFIG.models.length - 1) return tryLoadAI(0, modelIndex + 1);
                throw err;
            }
        }

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: { ideal: 480 }, height: { ideal: 640 } } });
                video.srcObject = stream;
                return new Promise(r => video.onloadedmetadata = r);
            } catch (err) {
                console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", err);
                showError(t.cameraError, err);
                throw err;
            }
        }

        async function initAI() {
            try {
                await loadModule();
                await tryLoadAI();
                await setupCamera();
                video.play();
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('overlay').style.display = 'flex';
                predict();
            } catch (err) {
                console.error("å…¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:", err);
                showError(t.netError, err);
            }
        }

        async function predict() {
            if (lastVideoTime !== video.currentTime && faceLandmarker) {
                lastVideoTime = video.currentTime;
                const result = faceLandmarker.detectForVideo(video, Date.now());
                if (result.faceLandmarks && result.faceLandmarks.length > 0) {
                    const lms = result.faceLandmarks[0];
                    // Nose tip is landmark 4
                    noseY = lms[4].y;
                    document.getElementById('calibration-hint').style.opacity = 0;
                } else {
                    noseY = null;
                    document.getElementById('calibration-hint').style.opacity = 0.8;
                }
            }
            requestAnimationFrame(predict);
        }

        // --- Game Loop ---
        function resetGame() {
            score = 0;
            gameSpeed = 8;
            bird = new Bird();
            pipes = [new Pipe(CANVAS_WIDTH + 200)];
            document.getElementById('score-value').innerText = score;
        }

        function spawnPipes() {
            const lastPipe = pipes[pipes.length - 1];
            if (lastPipe.x < CANVAS_WIDTH - PIPE_SPACING) {
                pipes.push(new Pipe(CANVAS_WIDTH));
            }
            if (pipes[0].x < -PIPE_WIDTH) {
                pipes.shift();
            }
        }

        function checkCollisions() {
            // Screen boundaries
            if (bird.y < 0 || bird.y > CANVAS_HEIGHT) return true;

            for (let p of pipes) {
                // Horizontal match
                if (bird.x + BIRD_SIZE / 3 > p.x && bird.x - BIRD_SIZE / 3 < p.x + PIPE_WIDTH) {
                    // Vertical miss gap
                    if (bird.y - BIRD_SIZE / 3 < p.gapY || bird.y + BIRD_SIZE / 3 > p.gapY + PIPE_GAP) {
                        return true;
                    }
                }
                // Score
                if (!p.passed && bird.x > p.x + PIPE_WIDTH) {
                    p.passed = true;
                    score++;
                    document.getElementById('score-value').innerText = score;
                    sfx.playPass();
                    gameSpeed += 0.1;
                }
            }
            return false;
        }

        function loop() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState === 'PLAYING') {
                bird.update(noseY);
                spawnPipes();
                for (let p of pipes) p.update(gameSpeed);

                if (checkCollisions()) {
                    gameState = 'GAMEOVER';
                    sfx.playHit();
                    showOverlay('GAMEOVER');
                    window.parent.postMessage({ type: 'GAME_OVER', score: score }, '*');
                }
            }

            // Draw
            for (let p of pipes) p.draw(ctx);
            bird.draw(ctx);

            frameId = requestAnimationFrame(loop);
        }

        function showOverlay(state) {
            const overlay = document.getElementById('overlay');
            const title = document.getElementById('overlay-title');
            const btn = document.getElementById('start-btn');
            overlay.style.display = 'flex';

            if (state === 'GAMEOVER') {
                title.innerText = t.gameOver;
                btn.innerText = t.restart;
            }
        }

        // --- Event Listeners ---
        document.getElementById('start-btn').addEventListener('click', () => {
            sfx.init();
            document.getElementById('overlay').style.display = 'none';
            resetGame();
            gameState = 'PLAYING';
        });

        initAI();
        loop();
    </script>
</body>

</html>